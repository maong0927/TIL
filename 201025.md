# 201025

## Markup vs Markdown

`markup` : 마크(Mark)로 둘러싸인 언어/ 마크 = 태그/ 태그로 문서의 골격을 잡아줌 

`markdown` : 마크업 언어의 일종 / 경량 마크업 언어임. / 쉽게 작성할 수 있는 것이 특징  

→ 둘이 반대 개념이 아님! 

## Javascript Framework

보통 자바스크립트 프레임워크는 MVC 나 MVVM 아키텍처를 사용한다. (Angular JS 는 MVW 아키텍처로 애플리케이션을 구조화 한다. ) 

`MVC 패턴` 

Model : 데이터 관리 

View : 화면에 보이는 부분 관리 

Controller : 어떤 작업(버튼 클릭, 텍스트 입력 등)을 받으면 컨트롤러는 모델 데이터를 조회하거나 수정하고, 변경된 사항을 뷰에 반영한다. 

## React

→ 구조가 MVC, MVW 등인 프레임워크와 달리 오직 V(View)만 신경 쓰는 라이브러리이다. 

→ 어떤 데이터가 변할 때마다 어떤 변화를 줄지 고민하는 게 아니라 그냥 기존 뷰를 날려버리고 처음부터 새로 렌더링하는 방식. 

Q.  항상 새로 렌더링하는데 어떻게 좋은 성능 유지 하고 안끊기게 할 수 있지? 

A. 리액트의 초기렌더링, 리렌더링 개념을 알면 됨. 

`초기렌더링` : Render() 함수 : 뷰의 component 들을 객체형태로 만듦 → 재귀적으로 객체를 돌면서 HTML 을 만든다. → DOM 요소에 넣는다.  

`리렌더링(조화과정)` : 데이터 업데이트 → 업데이트된 부분만 수정하는 게 아니라 업데이트 된 부분을 포함한 전체 뷰로 Render()  함수 호출 → 이전에 Render() 함수로 만들어 두었던 컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보와 비교 → 둘의 차이를 알아내 최소한의 연산으로 DOM 트리 업데이트  /  Virtual Dom 임 

## 클라이언트 측 자바스크립트의 전체 동작

*웹브라우저에서 자바스크립트가 하는 일*

- 웹 페이지의 Document 객체 제어 ( HTML 요소와 CSS 스타일 작업 )
- 웹 페이지의 Window 객체 제어 및 브라우저 제어 (Location, Navigator)
- 웹 페이지에서 발생하는 이벤트 처리
- HTTP를 이용한 통신 제어

*웹 브라우저가 제공하는 기능*

- 파일 읽기와 쓰기
- 데이터베이스 기능
- 비동기 통신
- 2차원, 3차원 컴퓨터 그래픽스 기능
- 키보드로 입력
- 마우스로 드래그 앤 드롭
- 멀티스레딩

*웹 브라우저에서의 자바스크립트 실행 순서*

1. Window 객체 생성 
2. Window 객체의 프로퍼티로 Document 객체 생성 ( Document 의 readyState 프로퍼티는 loading)
3. HTML 구문분석 시작 (DOM 트리 생성 시작) 
4. 이때 CSS ( Style ) 구문 분석은 같이 실행 됨. (스타일 규칙으로 만들어짐 )
5. DOM 트리 생성이 완료되면 Document 객체에 DOMContentLoaded 이벤트를 발생시킴. (readyState: interactive)
6. 외부 리소스 파일 읽어들임 (readyState: Complete)
7. window 객체에게 load 이벤트 발생 
8. 이때부터 다양한 이벤트 수신. 이벤트가 비동기로 호출됨. 
9. DOM 트리가 다 만들어졌을 때 스타일 규칙(CSSOM : CSS Object Model) 과 합쳐져서 `렌더 트리` 라는 또다른 트리 만듦. 렌더 트리는 표시해야 하는 정보만 저장되며 ( display: none으로 설정된 것들 / visibility: invisible 은 공간은 차지하지만 요소는 보이지 않게 하기 때문에 Render Tree 에 추가 ) 스타일 정보가 추가됨. 
10. DOM 의 각 노드 위치와 크기를 결정 ( `Layout` : 뷰포트 내에서 정확한 위치 계산 / 스타일과 속성에 따라 %, vh, vw 등이 pixel 단위로 변환 ) (cf: 그래픽이 표시되는 브라우저의 영역, 크기를 말함. 모바일의 경우 디스플레이의 크기, PC 의 경우 창의 크기에 따라 달라짐. / %, vw, vh, 로 그려지는 경우는 뷰포트의 크기가 달라질 때 마다 다시 계산해야 함.  )
11. 렌더트리를 스타일 정보를 바탕으로 그린다. ( `Paint` )
12. 렌더트리를 그리는 과정은 1. 처음 리소스를 읽어 들일 때, 2. 자바스크립트로 동적인 처리를 할 때, 3. 사용자의 조작으로 HTML/ CSS 코드가 바뀔 때마다 실행. 

cf) HTML 문서를 분석하는 것은 HTML 서버에서, CSS 스타일 시트를 분석하는 것은 CSS 스타일 시트에서 실행.

cf) 여기서 좀더 TMI를 추가하자면 렌더링 엔진은 더 나은 사용자경험을 위해 가능한 빠르게 내용을 표시하게 만들어졌습니다. 따라서 모든 HTML 파싱이 끝나기도 전에 이후의 과정을 수행하여 미리 사용자에게 보여줄 수 있는 일부 내용들을 출력하게 됩니다.

Q. 위 과정에서 성능 최적화? 

A. Reflow, Repaint 줄이기 

`Reflow(layout)`: 이벤트에 따라 html 요소나 위치 등 레이아웃 수치를 수정하면 자식 노드나 부모 노드들을 포함하여 Layout 과정을 다시 수행하게 된다. ( 영향 받는 모든 요소들의 위치나 크기를 새로 계산 )

페이지 초기 렌더링 시(최초 Layout), 윈도우 리사이징 시 (Viewport 크기 변경), 노드 추가 또는 변경, 요소의 위치, 크기 변경, 폰트 변경(텍스트 내용)과 이미지 크기 변경 

`Repaint(Paint)` : Reflow 만 하면 화면에는 아무일도 일어나지 않음. Reflow 뒤 Repaint 를 해야 변경된 내용이 화면에 출력 됨. 그러나 Repaint만 하는 경우도 있다. → background-color, visibility와 같이 레이아웃에는 영향을 주지 않는 스타일 속성이 변경되었을 때는 Reflow를 수행할 필요가 없기 때문에 Repaint만 수행하게 된다. 

React 의 Virtual Dom 이 빠른 이유? 스타일 변화가 일어날 때마다 여러번의 Reflow, Repaint가 발생하게 된다. Virtual DOM은 이렇게 변화가 일어나 Reflow, Repaint가 필요한 것들을 한번에 묶어서 dom에 전달하게 된다. 따라서 처리되는 Reflow, Repaint의 규모가 커질 수는 있지만 한번만 연산을 수행하게 된다. 이를 통해 여러번 Reflow, Repaint를 수행하며 연산이 반복적으로 일어나는 부분이 줄어들어 성능이 개선된다.

→ Reflow 와 Repaint 를 줄이는 법 

[브라우저 렌더링 과정 - Reflow Repaint, 그리고 성능 최적화](https://boxfoxs.tistory.com/408)

*JIT 컴파일러*

원래 : 실행속도가 웹 애플리케이션을 구동할만큼은 나오지 않았음. / 실행 중에 자바스크립트 코드를 컴파일 하는 JIT 컴파일러를 도입하면서 C++ 등으로 구현한 데스크톱 애플리케이션과 견줄 수 있을 만큼의 실행 속도를 구현함. 최신 웹 브라우저는 모두 JIT 컴파일러를 도입하여 자바스크립트 실행 속도의 고속화 꾀함. 

*겸손한 자바스크립트*

정의 : 자바스크립트는 웹페이지를 보는 사용자에게 무리하게 참견해서는 안된다. 

ex)  자바스크립트에 따라서 사용자가 웹페이지에서 제공받을 수 있는 정보가 달라져서는 안된다. 

```basic
1. 자바스크립트를 지원하지 않는 브라우저
2. 보안상의 이유로 스크립트를 꺼둔 경우
3. DOM 명세의 일부분을 브라우저 독자적으로 해석/지원하여 스크립트의 오류 혹은 지원의 범위가 다른 경우
4. 사용자가 브라우저를 사용하는 방법이 다른 경우( 대부분의 사용자가 마우스를 가지고 이용한다 하여, 
	 마우스를 이용할 때에만 작동하고, 키보드를 이용한 경우에는 작동하지 않을 경우. 
	 장애를 가진 사람들은 키보드를 가지고 이용할 수 있으며, 
	 그렇지 않다고 해도 키보드로 이용하는 게 편해 키보드를 이용할 수 있다.
```

목표 

1. 자바스크립트 코드와 HTML 마크업을 분리한다. → 분리함으로써 한 모듈이 변수가 다른 모듈의 변수를 덮어쓰는 일을 걱정할 필요 없이 독립적인 코드의 모듈들을 같은 페이지에서 포함시킬 수 있다. / 구조, 동작, 스타일을 분리해서 저장할 수 있다. 
2. 단계적으로 성능을 축소하는 것이다. → 자바스크립트는 HTML의 기능을 강화하기 위해서 사용되어야 하며 HTML의 내용은 자바스크립트 코드가 없거나 실행되지 않더라도 사용할 수 있어야 한다. / 자바스크립트는 HTML 의 사용성을 강화하기 위한 도구이다. 

ex) 사용자가 입력하는 입력양식은 데이터베이스에 저장되기 전에 유효성을 체크 해야 하는데 유효성 체크는 보안과도 직결될 수 있는 부분이기 때문에 반드시 체크를 해야한다. 이러한 유효성을 서버에서 하는 것은 제출과 응답 간의 딜레이가 존재하기 때문에 시간을 다소 소모하게 될 수 있다. 이럴 때 자바스크립트가 개입하여 사용자가 입력한 양식을 서버에 전송하기 전에 검토한다면, 사용자들이 빈번히 저지르는 실수를 서버를 거치지 않더라도 잡아 줄 수 있으며 이러한 인터페이스는 훨씬 빠르고 부드럽게 돌아가는 것처럼 느껴질 수 있다. 하지만 이러한 자바스크립트 역시 서버사이드 유효성 검증에 대해져서 사용되어야 한다. 자바스크립트만 이용한다면 부드러운 인터페이스를 제공할 수 있지만, 그러한 경우 유효성 검증을 우회하기는 아주 쉽다. 결국 사용자가 자바스크립트를 사용 여하를 떠나 검증을 체크하는 것은 서버에서 한다. 결국은 자바스크립트의 역할은 자바스크립트를 켜둔 사용자에게 약간이나마 편한 환경을 제공하는 것이지 그 이상의 Role은 없다.

3. HTML 페이지의 접근성을 해치지 않게 하는 것이다. 

4. 브라우저의 호환성을 생각한다. 

- 자바스크립트 코드들은 웹 페이지에서 생성된 Window 객체 하나를 공유하며 하나의 큰 프로그램으로 동작!

*동일 출처 정책(same origin policy)*

- 웹 페이지 위에서 동작하는 프로그램 (자바스크립트 등) 출처와 그 프로그램이 읽으려고 시도하는 데이터 출처가 서로 다를 경우에 리소스 간의 상호작용을 제한하는 정책을 말한다.

Q. 출처가 같다? 

A. 프로토콜이 같다/ 포트 번호가 같다/ 호스트 이름이 같다 → 이 세가지가 전부 충족되어야 함. 

→ CORS ( Cross Origin Policy 가 나옴 )

[Same-Origin Policy 동일 출처 정책과 CORS 에러](https://velog.io/@yejinh/CORS-4tk536f0db)

*Javascript Head vs Body 어디에 넣는 게 좋을까?*

1. `Head` 에 넣는 경우 : Javascript 로 화면에 뭔가를 보여줘야 하는 경우 . Body 에 넣으면 일시적으로 그 부분이 깨져 보일 수 있다. 
2. `Body` 에 넣는 경우 : 뭔가를 보여주지 않아도 되는 경우. Body 에 넣으면 화면에 전부 렌더링 한 뒤 스크립트 구문을 읽기 때문에 사용자에게 화면을 빨리 보여줄 수 있다. 

## Virtual DOM

가상의 DOM 트리. 렌더링 되지 않는 또 하나의 가상 트리 

모든 연산이 끝날 때 까지 기다렸다가 한번에 실제 DOM 트리에 변화된 부분만 적용시킨다.

물론 React 를 안써도 DomFragment에 모든 연산을 저장해 뒀다가 한번에 실제 DOM 트리에 적용시켜도 된다. 

그러나 이렇게 하면 어떤 값이 바뀌고 바뀌지 않았는지 직접 전부 탐지하고 있어야 한다. (그렇지 않으면 수정하지 않아도 되는 DOM 트리까지 수정할 수 있음.)

React 는 이런 관리를 자동으로 해준다!  → 이게 리엑트를 사용하는 이유! / 그리고 Virtual DOM 을 사용하면 DOM 요소를 조작할 때 다른 요소와 상호작용할 필요가 없다. → 즉, 각 변화들의 동기화 작업을 거치지 않으면서도 모든 작업을 하나로 묶어줄 수 있다. 

Q. 리액트를 언제 사용해야 할까? 

A. 지속적으로 데이터가 변화하는 대규모 어플리케이션 구축하기

→ Virtual DOM 을 사용한다고 해서 사용하지 않을 때와 비교해서 무조건 빠른 것은 아니다.  / 단순한 라우팅 정도만 있는 정적인 페이지에서는 리액트를 사용하지 않는 편이 더 나은 성능을 보인다. / 업데이트 처리 간결성이 Virtual DOM 이 제공할 수 있는 것! 

## React Lint 설정하기

[리액트 프로젝트에 ESLint 와 Prettier 끼얹기](https://velog.io/@velopert/eslint-and-prettier-in-react)